package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"io/ioutil"
	"k8s.io/client-go/rest"
	"net/http"
	fedv1b1 "sigs.k8s.io/kubefed/pkg/apis/core/v1beta1"
	genericclient "sigs.k8s.io/kubefed/pkg/client/generic"
	"sigs.k8s.io/kubefed/pkg/controller/util"
)
type ClusterManager struct {
	Fed_namespace string
	Host_config *rest.Config
	Host_client genericclient.Client
	Cluster_list *fedv1b1.KubeFedClusterList
	Cluster_configs map[string]*rest.Config
	Cluster_clients map[string]genericclient.Client
}

func ListKubeFedClusters(client genericclient.Client, namespace string) *fedv1b1.KubeFedClusterList {
	clusterList := &fedv1b1.KubeFedClusterList{}
	err := client.List(context.TODO(), clusterList, namespace)
	if err != nil {
		fmt.Println("Error retrieving list of federated clusters: %+v", err)
	}
	if len(clusterList.Items) == 0 {
		fmt.Println("No federated clusters found")
	}
	return clusterList
}

func KubeFedClusterConfigs(clusterList *fedv1b1.KubeFedClusterList, client genericclient.Client, fedNamespace string) map[string]*rest.Config {
	clusterConfigs := make(map[string]*rest.Config)
	for _, cluster := range clusterList.Items {
		config, _ := util.BuildClusterConfig(&cluster, client, fedNamespace)
		clusterConfigs[cluster.Name] = config
	}
	return clusterConfigs
}
func KubeFedClusterClients(clusterList *fedv1b1.KubeFedClusterList, cluster_configs map[string]*rest.Config) map[string]genericclient.Client {

	cluster_clients := make(map[string]genericclient.Client)
	for _, cluster := range clusterList.Items {
		clusterName := cluster.Name
		cluster_config := cluster_configs[clusterName]
		cluster_client := genericclient.NewForConfigOrDie(cluster_config)
		cluster_clients[clusterName] = cluster_client
	}
	return cluster_clients
}

func NewClusterManager() *ClusterManager {
	fed_namespace := "kube-federation-system"
	host_config, _ := rest.InClusterConfig()
	host_client := genericclient.NewForConfigOrDie(host_config)
	cluster_list := ListKubeFedClusters(host_client, fed_namespace)
	cluster_configs := KubeFedClusterConfigs(cluster_list, host_client, fed_namespace)
	cluster_clients := KubeFedClusterClients(cluster_list, cluster_configs)

	cm := &ClusterManager{
		Fed_namespace: fed_namespace,
		Host_config: host_config,
		Host_client: host_client,
		Cluster_list: cluster_list,
		Cluster_configs: cluster_configs,
		Cluster_clients: cluster_clients,
	}
	return cm
}

func (h *HttpManager) test(w http.ResponseWriter, r *http.Request){
	//fmt.Println("Connect Etcd Main")
	//fmt.Println("-----------------------------")
	//fmt.Println("Host : ", r.Host)
	//fmt.Println("URL : ", r.URL)
	//fmt.Println("URL.Host : ", r.URL.Host)
	//fmt.Println("URL.Path : ", r.URL.Path)
	//fmt.Println("URL.ForceQuery : ", r.URL.ForceQuery)
	//fmt.Println("URL.Fragment : ", r.URL.Fragment)
	//fmt.Println("URL.Opaque : ", r.URL.Opaque)
	//fmt.Println("URL.RawPath : ", r.URL.RawPath)
	//fmt.Println("URL.RawQuery : ", r.URL.RawQuery)
	//fmt.Println("URL.Scheme : ", r.URL.Scheme)
	//fmt.Println("URL.User : ", r.URL.User)
	//fmt.Println("RequestURI : ", r.RequestURI)
	//fmt.Println("Method : ", r.Method)
	//fmt.Println("RemoteAddr : ", r.RemoteAddr)
	//fmt.Println("Proto : ", r.Proto)
	//fmt.Println("Header : ", r.Header)

	clusterNames, ok := r.URL.Query()["clusterName"]

	fmt.Println(clusterNames, ok)
	if !ok || len(clusterNames[0]) < 1 {
		w.Write([]byte("Url Param 'clusterName' is missing"))
		return
	}

	cm := NewClusterManager()


	APISERVER := ""
	clusterName := clusterNames[0]
	if clusterName == "openmcp"{
		APISERVER = cm.Host_config.Host
	} else {
		for _, cluster := range cm.Cluster_list.Items{
			if cluster.Name == clusterName{
				APISERVER = cluster.Spec.APIEndpoint
			}
		}

	}

	fmt.Println(APISERVER)
	TOKEN := "eyJhbGciOiJSUzI1NiIsImtpZCI6InRkQm9ZRV9vTlA4bVV5MUJmck1najBvclVab3Z0VFp4YnVrTWJyek4tUTQifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrY2giLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlY3JldC5uYW1lIjoic2EtYWRtaW4tdG9rZW4tY3FmNmMiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoic2EtYWRtaW4iLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiI1ZGI3MDIzMy0yZmVkLTQzODUtYjJhZi0zMDZjYTY2MmRiOTAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a2NoOnNhLWFkbWluIn0.O-L2eEn0w8mxzu9SCyc3d2bGmU7XFAEIrn4-BpsHtYuUUNLXEfyPBNE3QCCKBj6j0whuYZc9PH_j6hIxni1AWFQInMZY93gYcbujxbp5Pq75Y_eK3ODRguF4CUR3aSHZj-WWRJ90TQtb7txpKXYq2PdWlWo1AsiJsan2qr5iEgRFTuaC_DuHq3ourNl3VN6QlY35a3kX3WDHJEHf5V5kEVvBZR2o3d8quiJHlpN6wo-eTXVDvCUHCds6HuNi1kMtC7RSKEV7EPolOfRUHt_Bpeg3Q3p4JEczsSoPG0cyJnan5Z26LI3bC8nT4b_WNoVL0FcXG0aRXsb8IUkik0MOBw"

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}


	req, err := http.NewRequest("GET", "https://"+APISERVER+r.URL.Path, nil)
	if err != nil {
		fmt.Println("Check1", err)
		// handle err
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+ TOKEN)

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("Check2", err)
		// handle err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Check3", err)
		panic(err.Error())
	}

	fmt.Printf("%s\n", body)

}
type HttpManager struct{
	HTTPServer_IP string
	HTTPServer_PORT string
}
func main() {
	HTTPServer_IP := "10.0.3.20"
	HTTPServer_PORT := "8190"

	httpManager := &HttpManager{
		HTTPServer_IP: HTTPServer_IP,
		HTTPServer_PORT: HTTPServer_PORT,
	}

	handler := http.NewServeMux()

	handler.HandleFunc("/", httpManager.test)


	server := &http.Server{Addr: HTTPServer_IP+":"+HTTPServer_PORT, Handler: handler}

	fmt.Println("Run OpenMCP API Server")
	server.ListenAndServe()
}