package apiServerMethod

import (
	"crypto/tls"
	"fmt"
	"github.com/dgrijalva/jwt-go"
	"github.com/ghodss/yaml"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	cobrautil "openmcp/openmcp/omcpctl/util"
	"os"
	"strings"
	"time"
)

func saveTokenToFile(token string) {
	filename := "/var/lib/omcpctl/token"
	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	err = f.Truncate(0)
	_, err = fmt.Fprintln(f, "token: " + token)
	if err != nil {
		fmt.Println(err)
	}
}
func getTokenWithFile() (string, error){
	// 토큰파일
	filename := "/var/lib/omcpctl/token"

	// 토큰파일이 없는경우
	// 아직 한번도 토큰발급을 하지 않은 경우 새로토큰을 발급받는다.
	_, err := os.Stat(filename)
	if os.IsNotExist(err){
		fmt.Println(filename+ " file is not")
		return "", cobrautil.NewError("File not exist")
	}

	tokenMap := make(map[string]string)

	yamlFile, err := ioutil.ReadFile(filename)
	if err != nil {
		log.Printf("yamlFile.Get err   #%v ", err)
	}
	err = yaml.Unmarshal(yamlFile, &tokenMap)
	if err != nil {
		log.Fatalf("Unmarshal: %v", err)
	}

	// 파일은 있지만 토큰이 없는경우
	// 새로운 토큰을 발급받는다.
	if _, ok := tokenMap["token"]; !ok {
		return "", cobrautil.NewError("token not exist")
	}

	// 토큰이 있는경우 토큰의 유효기간을 검사한다.
	tokenString := tokenMap["token"]
	//tokenString := "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2MDAwNzEyODgsImlhdCI6MTYwMDA3MTI4MywidXNlciI6Im9wZW5tY3AifQ.koZwjMM3TOE8g4ygjDxqgOrulQ6xoGoNnKfc9O0Nq6Y"
	claims := jwt.MapClaims{}
	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return []byte("<YOUR VERIFICATION KEY>"), nil
	})
	// ... error handling
	_ = token

	// do something with decoded claims
	// exp는 토큰의 유효기간을 나타내는 값
	exp := time.Duration(claims["exp"].(float64)) * time.Nanosecond
	//lat := time.Duration(claims["iat"].(float64)) * time.Nanosecond

	exp_sec := int(exp.Seconds()*1000000000)
	//lat_sec := int(lat.Seconds()*1000000000)
	cur_sec := int(time.Now().Unix())


	// 만료시간 300초 전이면 새로 토큰을 발급받는다.
	if exp_sec - cur_sec < 300 {
		return "", cobrautil.NewError("Token is expired")
	}

	return tokenString, nil
}
func getToken() (string, error) {
	// 이전에 발급 받은 토큰 액세스
	// 만료시간을 검사하여 만료되지 않은경우면 해당 토큰 사용
	// 만료 5분전인 경우 새로운 토큰을 발급받음
	token, err := getTokenWithFile()
	if err == nil {
		return token, nil
	}
	//fmt.Println(token, err)

	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	LINK := "http://"+cobrautil.OpenMCPAPIServer+"/token"

	data := url.Values{}
	data.Set("username", "openmcp")
	data.Set("password", "keti")


	req, err := http.NewRequest("POST", os.ExpandEnv(LINK), strings.NewReader(data.Encode()))
	if err != nil {
		// handle err
		log.Fatalln(err)
		return "", err
	}
	//req.Header.Set("Content-type", "application/json")
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")


	resp, err := client.Do(req)
	if err != nil {
		// handle err
		log.Fatalln(err)
		return "", err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Check3", err)
		panic(err.Error())
	}

	var prettyYaml map[string]string
	err = yaml.Unmarshal(body, &prettyYaml)
	if err != nil {
		panic(err.Error())
		return "", err
	}

	if _, ok := prettyYaml["token"]; !ok{

		fmt.Println("Cannot Get Token: ", string(body))
		return "", cobrautil.NewError("Cannot Get Token")
	}

	//fmt.Println(string(body))

	saveTokenToFile(prettyYaml["token"])
	return prettyYaml["token"], nil



}
func GetAPIServer(LINK string) ([]byte, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	req, err := http.NewRequest("GET", os.ExpandEnv(LINK), nil)
	if err != nil {
		// handle err
	}
	TOKEN, err := getToken()

	if err != nil {
		log.Fatalln(err)
	}
	req.Header.Set("Authorization","Bearer "+ TOKEN)

	resp, err := client.Do(req)
	if err != nil {
		// handle err
		fmt.Println(err)
		return nil, err
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Check3", err)
		panic(err.Error())
	}
	return body, nil
}
func DeleteAPIServer(LINK string, body io.Reader) ([]byte, error) {
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	req, err := http.NewRequest("DELETE", LINK, body)
	if err != nil {
		// handle err
	}
	TOKEN, err := getToken()

	if err != nil {
		log.Fatalln(err)
	}

	req.Header.Set("Content-Type", "application/yaml")
	req.Header.Set("Authorization", "Bearer "+ TOKEN)

	resp, err := client.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	_body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Check3", err)
		panic(err.Error())
	}

	return _body, nil

}
func PostAPIServer(LINK string, body io.Reader) ([]byte, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}


	req, err := http.NewRequest("POST", os.ExpandEnv(LINK), body)
	if err != nil {
		return nil, err
	}
	TOKEN, err := getToken()

	if err != nil {
		log.Fatalln(err)
	}

	req.Header.Set("Content-Type", "application/yaml")
	req.Header.Set("Authorization", "Bearer " + TOKEN)

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	_body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Check3", err)
		panic(err.Error())
	}

	return _body, nil
}
func PutAPIServer(LINK string, body io.Reader) ([]byte, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}


	req, err := http.NewRequest("PUT", os.ExpandEnv(LINK), body)
	if err != nil {
		// handle err
	}
	TOKEN, err := getToken()

	if err != nil {
		log.Fatalln(err)
	}
	req.Header.Set("Content-Type", "application/yaml")
	req.Header.Set("Authorization", "Bearer "+TOKEN)

	resp, err := client.Do(req)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	_body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Check3", err)
		panic(err.Error())
	}

	return _body, nil
}